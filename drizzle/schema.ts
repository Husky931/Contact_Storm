import { pgTable, index, uniqueIndex, foreignKey, serial, text, timestamp, unique, boolean, jsonb, real, integer } from "drizzle-orm/pg-core"
import { sql } from "drizzle-orm"



export const domainSearchTerms = pgTable("domain_search_terms", {
	id: serial().primaryKey().notNull(),
	domain: text().notNull(),
	searchTerm: text("search_term").notNull(),
	firstSeen: timestamp("first_seen", { mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_search_term_domain").using("btree", table.domain.asc().nullsLast().op("text_ops")),
	uniqueIndex("unique_domain_search_term").using("btree", table.domain.asc().nullsLast().op("text_ops"), table.searchTerm.asc().nullsLast().op("text_ops")),
	foreignKey({
			columns: [table.domain],
			foreignColumns: [domains.domain],
			name: "domain_search_terms_domain_domains_domain_fk"
		}),
]);

export const domains = pgTable("domains", {
	id: serial().primaryKey().notNull(),
	domain: text().notNull(),
	searchQueryUsed: text("search_query_used").notNull(),
	industry: text(),
	firstSeen: timestamp("first_seen", { mode: 'string' }).defaultNow().notNull(),
	formFound: boolean("form_found"),
	submitted: boolean().default(false),
	messageType: text("message_type"),
	contactAttemptDate: timestamp("contact_attempt_date", { mode: 'string' }),
	contactEmail: text("contact_email"),
	contactPhone: text("contact_phone"),
	contactStatus: text("contact_status"),
	lastContactAttempt: timestamp("last_contact_attempt", { mode: 'string' }),
	seoEnabled: boolean("seo_enabled").default(false),
}, (table) => [
	index("idx_contact_status").using("btree", table.contactStatus.asc().nullsLast().op("text_ops")),
	index("idx_domain").using("btree", table.domain.asc().nullsLast().op("text_ops")),
	index("idx_message_type").using("btree", table.messageType.asc().nullsLast().op("text_ops")),
	index("idx_submitted").using("btree", table.submitted.asc().nullsLast().op("bool_ops")),
	unique("domains_domain_unique").on(table.domain),
]);

export const blacklist = pgTable("blacklist", {
	id: serial().primaryKey().notNull(),
	pattern: text().notNull(),
	reason: text(),
	enabled: boolean().default(true).notNull(),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	unique("blacklist_pattern_unique").on(table.pattern),
]);

export const contactAttempts = pgTable("contact_attempts", {
	id: serial().primaryKey().notNull(),
	domain: text().notNull(),
	status: text().default('pending').notNull(),
	attemptedAt: timestamp("attempted_at", { mode: 'string' }).defaultNow().notNull(),
	contactPageUrl: text("contact_page_url"),
	formDetectionMethod: text("form_detection_method"),
	fieldMappingJson: jsonb("field_mapping_json"),
	messageSubject: text("message_subject"),
	messageBody: text("message_body"),
	// TODO: failed to parse database type 'bytea'
	proofScreenshot: unknown("proof_screenshot"),
	errorMessage: text("error_message"),
	seoReportUrlHash: text("seo_report_url_hash"),
}, (table) => [
	index("idx_contact_attempt_at").using("btree", table.attemptedAt.asc().nullsLast().op("timestamp_ops")),
	index("idx_contact_attempt_domain").using("btree", table.domain.asc().nullsLast().op("text_ops")),
	index("idx_contact_attempt_status").using("btree", table.status.asc().nullsLast().op("text_ops")),
	foreignKey({
			columns: [table.domain],
			foreignColumns: [domains.domain],
			name: "contact_attempts_domain_domains_domain_fk"
		}),
	foreignKey({
			columns: [table.seoReportUrlHash],
			foreignColumns: [seoReports.urlHash],
			name: "contact_attempts_seo_report_url_hash_seo_reports_url_hash_fk"
		}),
]);

export const seoReports = pgTable("seo_reports", {
	id: serial().primaryKey().notNull(),
	domain: text().notNull(),
	analyzedAt: timestamp("analyzed_at", { mode: 'string' }).defaultNow().notNull(),
	overallScore: real("overall_score"),
	lighthousePerformance: real("lighthouse_performance"),
	lighthouseAccessibility: real("lighthouse_accessibility"),
	lighthouseBestPractices: real("lighthouse_best_practices"),
	lighthouseSeo: real("lighthouse_seo"),
	lcp: real(),
	cls: real(),
	inp: real(),
	fcp: real(),
	ttfb: real(),
	technicalSeoScore: real("technical_seo_score"),
	hasTitle: boolean("has_title"),
	titleContent: text("title_content"),
	hasMetaDescription: boolean("has_meta_description"),
	metaDescriptionContent: text("meta_description_content"),
	hasCanonical: boolean("has_canonical"),
	canonicalUrl: text("canonical_url"),
	hasRobotsTxt: boolean("has_robots_txt"),
	hasSitemapXml: boolean("has_sitemap_xml"),
	sitemapUrl: text("sitemap_url"),
	hasHreflang: boolean("has_hreflang"),
	hasStructuredData: boolean("has_structured_data"),
	structuredDataTypes: jsonb("structured_data_types"),
	securityScore: real("security_score"),
	isHttps: boolean("is_https"),
	sslValid: boolean("ssl_valid"),
	sslExpiryDays: integer("ssl_expiry_days"),
	hasHsts: boolean("has_hsts"),
	hasCsp: boolean("has_csp"),
	hasXFrameOptions: boolean("has_x_frame_options"),
	hasXContentTypeOptions: boolean("has_x_content_type_options"),
	securityHeaders: jsonb("security_headers"),
	contentQualityScore: real("content_quality_score"),
	wordCount: integer("word_count"),
	hasH1: boolean("has_h1"),
	h1Count: integer("h1_count"),
	h2Count: integer("h2_count"),
	imageCount: integer("image_count"),
	imagesWithAlt: integer("images_with_alt"),
	altTextCoverage: real("alt_text_coverage"),
	internalLinkCount: integer("internal_link_count"),
	externalLinkCount: integer("external_link_count"),
	mobileReadinessScore: real("mobile_readiness_score"),
	hasViewportMeta: boolean("has_viewport_meta"),
	viewportContent: text("viewport_content"),
	isMobileResponsive: boolean("is_mobile_responsive"),
	internationalSeoScore: real("international_seo_score"),
	detectedLanguage: text("detected_language"),
	hasCharsetDeclaration: boolean("has_charset_declaration"),
	charsetValue: text("charset_value"),
	hreflangTags: jsonb("hreflang_tags"),
	hasEnglishVersion: boolean("has_english_version"),
	trustSignalsScore: real("trust_signals_score"),
	hasContactPage: boolean("has_contact_page"),
	contactPageUrl: text("contact_page_url"),
	hasSocialLinks: boolean("has_social_links"),
	socialLinksFound: jsonb("social_links_found"),
	hasCertificationMentions: boolean("has_certification_mentions"),
	certificationsFound: jsonb("certifications_found"),
	hasPrivacyPolicy: boolean("has_privacy_policy"),
	hasTermsOfService: boolean("has_terms_of_service"),
	markdownReport: text("markdown_report").notNull(),
	analysisError: text("analysis_error"),
	analysisSuccessful: boolean("analysis_successful").default(false).notNull(),
	socialPreviewScore: real("social_preview_score"),
	ogTitle: text("og_title"),
	ogDescription: text("og_description"),
	ogImage: text("og_image"),
	ogImageIsAbsolute: boolean("og_image_is_absolute"),
	twitterCard: text("twitter_card"),
	socialPreviewIssues: jsonb("social_preview_issues"),
	imageOptimizationScore: real("image_optimization_score"),
	totalImages: integer("total_images"),
	modernFormatCount: integer("modern_format_count"),
	modernFormatPercent: real("modern_format_percent"),
	lazyLoadedCount: integer("lazy_loaded_count"),
	missingLazyLoad: integer("missing_lazy_load"),
	aboveFoldLazyLoaded: integer("above_fold_lazy_loaded"),
	missingDimensions: integer("missing_dimensions"),
	brokenImages: jsonb("broken_images"),
	responsiveImages: integer("responsive_images"),
	linkHealthScore: real("link_health_score"),
	totalInternalLinks: integer("total_internal_links"),
	totalExternalLinks: integer("total_external_links"),
	brokenInternalLinksCount: integer("broken_internal_links_count"),
	brokenExternalLinksCount: integer("broken_external_links_count"),
	brokenInternalLinks: jsonb("broken_internal_links"),
	brokenExternalLinks: jsonb("broken_external_links"),
	redirectChainsCount: integer("redirect_chains_count"),
	nofollowLinks: integer("nofollow_links"),
	genericAnchors: integer("generic_anchors"),
	schemaAnalysisScore: real("schema_analysis_score"),
	schemasFound: jsonb("schemas_found"),
	totalSchemas: integer("total_schemas"),
	hasBreadcrumbs: boolean("has_breadcrumbs"),
	hasOrganization: boolean("has_organization"),
	hasFaq: boolean("has_faq"),
	hasArticle: boolean("has_article"),
	hasProduct: boolean("has_product"),
	hasLocalBusiness: boolean("has_local_business"),
	hasHowTo: boolean("has_how_to"),
	sslGradeScore: real("ssl_grade_score"),
	sslGrade: text("ssl_grade"),
	sslProtocols: jsonb("ssl_protocols"),
	sslVulnerabilities: jsonb("ssl_vulnerabilities"),
	sslChainIssues: jsonb("ssl_chain_issues"),
	titleLength: integer("title_length"),
	titleTooLong: boolean("title_too_long"),
	descriptionLength: integer("description_length"),
	descriptionTooLong: boolean("description_too_long"),
	metaRobots: text("meta_robots"),
	isNoIndex: boolean("is_no_index"),
	isNoFollow: boolean("is_no_follow"),
	headingHierarchyValid: boolean("heading_hierarchy_valid"),
	headingHierarchyIssues: jsonb("heading_hierarchy_issues"),
	h3Count: integer("h3_count"),
	h4Count: integer("h4_count"),
	h5Count: integer("h5_count"),
	h6Count: integer("h6_count"),
	readabilityScore: real("readability_score"),
	readabilityGrade: text("readability_grade"),
	paragraphCount: integer("paragraph_count"),
	avgParagraphLength: real("avg_paragraph_length"),
	sentenceCount: integer("sentence_count"),
	avgSentenceLength: real("avg_sentence_length"),
	listCount: integer("list_count"),
	tableCount: integer("table_count"),
	videoCount: integer("video_count"),
	iframeCount: integer("iframe_count"),
	hasFaqSection: boolean("has_faq_section"),
	hasTableOfContents: boolean("has_table_of_contents"),
	analyzerErrors: jsonb("analyzer_errors"),
	seoReportOpened: boolean("seo_report_opened").default(false).notNull(),
	seoReportLastOpened: timestamp("seo_report_last_opened", { mode: 'string' }),
	seoReportTimesOpened: integer("seo_report_times_opened").default(0).notNull(),
	reportDownloaded: boolean("report_downloaded").default(false).notNull(),
	urlHash: text("url_hash").notNull(),
}, (table) => [
	index("idx_seo_report_analyzed_at").using("btree", table.analyzedAt.asc().nullsLast().op("timestamp_ops")),
	index("idx_seo_report_domain").using("btree", table.domain.asc().nullsLast().op("text_ops")),
	index("idx_seo_report_overall_score").using("btree", table.overallScore.asc().nullsLast().op("float4_ops")),
	foreignKey({
			columns: [table.domain],
			foreignColumns: [domains.domain],
			name: "seo_reports_domain_domains_domain_fk"
		}),
	unique("seo_reports_url_hash_unique").on(table.urlHash),
]);

export const searchTerms = pgTable("search_terms", {
	id: serial().primaryKey().notNull(),
	query: text().notNull(),
	enabled: boolean().default(true).notNull(),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	unique("search_terms_query_unique").on(table.query),
]);
